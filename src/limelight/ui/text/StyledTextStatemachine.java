// This file was generated by the Ruby Statemachine Library (http://slagyr.github.com/statemachine).
// Generated at 15:52:48 March 25, 2010
package limelight.ui.text;

public class StyledTextStatemachine
{
  // Instance variables
  public final State DIAGNOSTICS = new DiagnosticsState(this);
  public final State LOCKED = new LockedState(this);
  public final State UNLOCKED = new UnlockedState(this);
  public final State OPERATIONAL = LOCKED;
  private State state = LOCKED;

  private StyledTextStatemachineContext context;

  // Statemachine constructor
  public StyledTextStatemachine(StyledTextStatemachineContext context)
  {
    this.context = context;
    context.operate();
    context.lock();
  }

  // The following is boiler plate code standard to all statemachines
  public StyledTextStatemachineContext getContext()
  {
    return context;
  }

  public State getState()
  {
    return state;
  }

  public void setState(State newState)
  {
    state = newState;
  }

  // Event delegation
  public void coin()
  {
    state.coin();
  }

  public void diagnose()
  {
    state.diagnose();
  }

  public void operate()
  {
    state.operate();
  }

  public void pass()
  {
    state.pass();
  }

  // Standard exception class added to all statemachines.
  public static class StatemachineException extends RuntimeException
  {
    public StatemachineException(State state, String event)
    {
      super("Missing transition from '" + state.getClass().getSimpleName() + "' with the '" + event + "' event.");
    }
  }

  // The base state
  public static abstract class State
  {
    protected StyledTextStatemachine statemachine;

    public State(StyledTextStatemachine statemachine)
    {
      this.statemachine = statemachine;
    }

    public void coin()
    {
      throw new StatemachineException(this, "coin");
    }

    public void diagnose()
    {
      throw new StatemachineException(this, "diagnose");
    }

    public void operate()
    {
      throw new StatemachineException(this, "operate");
    }

    public void pass()
    {
      throw new StatemachineException(this, "pass");
    }

  }

  // State implementations
  public static class DiagnosticsState extends State
  {
    public DiagnosticsState(StyledTextStatemachine statemachine)
    {
      super(statemachine);
    }

    public void operate()
    {
      statemachine.getContext().beep();
      statemachine.setState(statemachine.OPERATIONAL);
      statemachine.getContext().operate();
      statemachine.getContext().lock();
    }

  }

  public static class LockedState extends State
  {
    public LockedState(StyledTextStatemachine statemachine)
    {
      super(statemachine);
    }

    public void coin()
    {
      statemachine.setState(statemachine.UNLOCKED);
      statemachine.getContext().unlock();
    }

    public void diagnose()
    {
      statemachine.getContext().beep();
      statemachine.setState(statemachine.DIAGNOSTICS);
      statemachine.getContext().disable();
    }

    public void pass()
    {
      statemachine.getContext().alarm();
      statemachine.setState(statemachine.LOCKED);
    }

  }

  public static class OperationalState extends State
  {
    public OperationalState(StyledTextStatemachine statemachine)
    {
      super(statemachine);
    }

    public void diagnose()
    {
      statemachine.getContext().beep();
      statemachine.setState(statemachine.DIAGNOSTICS);
      statemachine.getContext().disable();
    }

  }

  public static class UnlockedState extends State
  {
    public UnlockedState(StyledTextStatemachine statemachine)
    {
      super(statemachine);
    }

    public void coin()
    {
      statemachine.getContext().thanks();
      statemachine.setState(statemachine.UNLOCKED);
    }

    public void diagnose()
    {
      statemachine.getContext().beep();
      statemachine.setState(statemachine.DIAGNOSTICS);
      statemachine.getContext().disable();
    }

    public void pass()
    {
      statemachine.setState(statemachine.LOCKED);
      statemachine.getContext().lock();
    }

  }

}
